# Глава 27. Асинхронные вычислительные операции

### Контексты исполнения

С каждым поток связан определённый контекст исполнения. Он включает в себя:

* Параметры безопасности
  * Сжатый стек
  * Свойство Principal объекта Thread
  * Идентификационные данные Windows
* Параметры хоста \(System.Threading.HostExecutionContextManager\)
* Контекстные данные логического вызова

По умолчанию CLR копирует контекст исполнения самого первого потока во все вспомогательные потоки. В свою очередь в дочерние потоки этих потоков будет копироваться уже их контекст исполнения.

Можно запретить копирование контекста исполнения \(System.Threading.ExecutionContext\).

### Задания \(Task\)

Написано, что при явном ожидании окончания задания \(_Написано про Wait, но что насчёт Result?_\), система проверяет началось ли уже выполнение задания в случае если да вызывающий поток блокируется до выполнения задания, но если задание ещё не началось выполняться, система может \(в зависимости от объекта TaskScheduler\) выполнить его при помощи вызывающего потока.

_**Как настраивается выбор поведения ? - нужны грязные подробности!**_

### Планировщики заданий

_**Что возвращает в сорсах вызов TaskScheduler.FromCurrentSynchronizationContext\(\) - я подозреваю что SynchronizationContext.Current**_

_**Проверит какие интерфейсы реализует TaskScheduler и SynchronizationContext**_

В FCL cуществует два производных класса от TaskScheduler - планировщик заданий в пуле потоков и планировщик заданий контекста синхронизации.

### Методы For, ForEach, Invoke класса Parallel

### Встроенный язык параллельных запросов

### Периодические вычислительные операции

### Как пул управляет потоками

Внутренняя реализация может меняться, всё что нужно знать - создаёт столько потоков сколько нужно, когда потоков становится много и они не используется удаляет их.

