---
book: 'Clr via C#'
tags: synopsis
---

# Глава 20. Исключения и управление состоянием

### Оставшиеся вопосы

1. Что такое кадры в контексте StackTrace ?
2. Что происходит с потоками с необработанными исключниями? - Поток будет просто убит операционной системой или будет завершён процесс?

### CLS-совместимые и CLS-несовместимые исключения

CLR позволяет бросать любые объекты как исключения, а не только наследующиеся от класса System.Exception. Однако CLS-совместимыми считаются только исключения наследующиеся от System.Exception. Также компилятор языка C\# позволяет бросать только исключения наследующиеся от System.Exception.

Если в языке, который позволяет бросать любые типы объектов как исключения выбросить такой объект \(не наследующийся от System.Exception\) как исключение. То начиная с CLR 2.0 среда обернёт его в `System.Runtime.CompilerServices.RuntimeWrappedException`

И его можно будет отловить блоком catch \(до 2.0 такие исключения нельзя было отловить блоком catch\).

### System.Exception

#### Свойство StackTrace

Строка в этом свойстве генерируется CLR. Если просто создать объект исключения и прочитать его свойство StackTrace то результатом будет null.

Когда исключение возникает CLR делает запись о точке его возникновения. Когда исключение попадает в блок catch CLR делает запись о точке обнаружения исключения. Если в блоке catch обратиться к свойству StackTrace исключения, то CLR генерирует строку в которой будут находится все методы от точки возникновения исключения, до точки его обнаружения.

Если в блоке catch заново выбросить исключение, то это будет считаться новой точкой возникновения исключения, CLR будет считать, что точка возникновения исключения - текущее место и в StackTrace эта точка будет указана как самая первая.

Если в блоке catch перевыбросить исключение \(просто вызвать throw без объекта исключения\), то начальная точка не будет перезаписана и будет доступен полный StackTrace от начальной точки исключения.

Строка со стектрейсом не включает методы находящиеся выше места блока catch. Если вам нужно получить полный стектрейс от начала потока до точки обработки исключения, можно использовать тип `System.Diagnostics.StackTrace`

Если CLR находит для ваших сборок pdb-файлы \(файлы символических имён отладки\), она включает в строку стектрейса пути файлов исходного кода и номера строк.

В стектрейсе могут отсутствовать имена каких-то методов - это может происходить из-за инлайнинга. В дебаг конфигурации инлайнинг запрещён.

Также у метода можно использовать атрибут `MethodImplAttribute`и настраивать инлайнинг для него в ручную.

```
internal sealed class SomeType {
    [System.Runtime.CompilerServices.MethodImpl(MethodImplOptions.NoInlining)]
    public void SomeMethod() {

    }
}
```

### Необработанные исключения

CLR обнаружив в процессе поток с необработанным исключением немедленно уничтожает этот поток - это всё что написано, ничего не написано про завершение процесса, хотя дальше это вроде как подразумевается.

### Области ограниченного выполнения

Constrained Executation Region - CER.

[https://docs.microsoft.com/en-us/dotnet/framework/performance/constrained-execution-regions](https://docs.microsoft.com/en-us/dotnet/framework/performance/constrained-execution-regions)

Регион try помеченный таким образом даёт дополнительные гарантии по тому что блоки catch и finally будут вызваны без ошибок. Фактически блоки catch и finally будут заранее скомпилированы \(сборки загружены, созданы типы объектов в куче загрузчика домена, вызваны статические конструкторы, скомпилирован IL код в машинный\) перед входом в блок try.

Смотреть документацию для `RunitmeHelper.PrepareContrainedRegion()`

Ещё похоже в коде в такой области не может быть выкинута ThreadAbortException.

