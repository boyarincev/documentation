# Глава 29. Примитивные конструкции синхронизации потоков

### Примитивные конструкции пользовательского режима и режима ядра

Конструкции пользовательского режима напрямую поддерживаются на аппаратном уровне - из-за этого они обладают намного большим быстродействием, чем конструкции режима ядра. Но из-за аппаратной поддержки виндовз во время блокировки потока не знает, что поток заблокирован и думает, что он продолжает свою обычную работу и продолжает выделять ему кванты времени для работы.

Примитивные конструкции режима ядра предоставляются операционной системой и требуют от потока вызова функций находящихся в ядре. Переход потока из пользовательского режима в режим ядра - это дорогая операция, требующая значительных ресурсов. Но плюс в том, что заблокированным таким образом поток усыпляется виндовз, до момента, когда необходимый ресурс будет освобождён.

Ситуация с бесконечно заблокированным потоком конструкцией пользовательского режима называется livelock.

Конструкцией режима ядра deadlock.

### Конструкции пользовательского режима

Система гарантирует атомарность чтения и записи только следующих типов: Ссылочных типов, char, \(S\)byte, \(U\)Int16, \(U\)Int32, \(U\)IntPtr, Single. При многопоточном доступе ко всем остальным типам необходима синхронизация потоков.

### Volatile-конструкции

C\# компилятор, JIT-компилятор, и даже процессор могут оптимизировать выполняемый код.

Эти оптимизации гарантируют сохранение назначения кода, но могут поменять способ выполнения которым это назначение достигается. И эти оптимизации не учитывают, что доступ к коду может осуществляться в многопоточном режиме.

Использование класса Volatile отключает оптимизации компиляторов и даже процессора \(_что именно отключает у процессора?_\).

#### Volatile.Write

Заставляет записать значение непосредственно в момент вызова. Более ранние загрузки и сохранения должны происходить до вызова этого метода.

#### Volatile.Read

Заставляет прочитать значение непосредственно в момент обращения. Более поздние загрузки и сохранения должны происходить после вызова этого метода.

#### Ситуация, когда можно использовать Volatile

Благодаря свойствам Volatile можно реализовать синхронизацию с использованием переменной или поля класса. С помощью Volatile нужно изменять состояние только синхронизационной переменной, такую переменную нужно рассматривать как флаг для каких-то действий со стороны других потоков. Если вы хотите установить синхронизационную переменную в определённое состояние, то вам необходима все действия вашего алгоритма произвести до установки этой переменной. Если вы читаете синхронизационную переменную, то вам необходимо все действия вашего алгоритма произвести после того, как вы прочитаете синхронизационную переменную и убедитесь, что она в нужном вам состоянии. Порядок действий в вашем коде \(то как вы пишите код\) остаётся таким же как если бы вы его писали для однопоточного кода, за одним лишь исключением, что состояние синхронизационной переменной вы читаете и записываете с помощью Volatile, что делает ваш код рабочим и для многопоточного окружения.

##### Общий смысл

Устанавливаем переменную в определённое состояние с помощью Volatile.Write\(ref obj\) после того как произведём все необходимые действия - это гарантирует, что все необходимые действия в этом методе были произведены до установки состояния переменной \(не было никаких оптимизационных перестановок\). Это состояние является сигналом готовности к чему-либо. Из другого потока читаем эту переменную с помощью Volatile.Read\(\) и если она в нужном нам состоянии, то производим какие-то действия - использование Volatile.Read\(\) гарантирует нам что значение будет читаться до того как будут производиться остальные действия в этом методе.

#### Поле с ключевым словом Volatile

Поле можно пометить ключевым словом Volatile и тогда доступ к нему будет осуществляться в виде волатильного чтения и записи.

Рихтер говорит, что в этом случае C\# и Jit-компиляторы не будут кэшировать значение этого поля в регистрах.

И приводит пример: mamount = mamount + m\_amount

В этом случае значение m\_amount будет читаться два раза в разные регистры, складываться и затем записываться в регистр, тогда как в обычном случае операция была произведена бы с помощью регистрового сдвига.

Непонятно в каких ещё случаях будут проблемы с регистрами. Любые чтения и записи будут осуществляться с помощью волатильного чтения и записи и если вы используете синхронизационную переменную не только для установки значения флага, но прозводите много каких-то ещё действий над ней, то вероятно в этом случае вы будете сталкиваться с проблемой отсутствия кэширования в регистрах.

### Interlocked-конструкции

Позволяют провести безопасную для многопочтоного доступа операцию чтения и/или записи. Ставят барьер в памяти - записи переменных находящиеся перед этим методом будут выполняться до его выполнения. Чтения переменных, находящиеся после этого метода, будут выполняться после его выполнения.

#### Паттерн блокировки с использованием Interlocked

Используется метод Compare.Exchange

У нас есть ресурс, на основе которого происходит блокировка. Допустим у него может быть два состояния true - заблокирован, false - не заблокирован.

```
private bool resourceLocked = false;

public void Enter()
{
    while(true)
    {
        //Мы зацикливаемся в цикле, пока не поменяем значение с false на true.
        //Если кто-то до нас поменяет значение, то условие не будет проходить.
        //Если мы меняем значение, то заходим в условие
        //Метод Exchange возвращает значение, которое было заменено.
        if(Interlocked.Exchange(ref resourceLocked, true) == false)
        {
            DoWork();
            break;
        }
    }
}
```

#### Универсальный Interlocked-паттерн

Interlocked содержит только несколько методов операций: Increment, Decrement.

Но существует паттерн используя который с помощью метода Interlocked.CompareExchange\(\) можно производить любые операции над типами: Int32, Int64, Single, Double, Object, и обобщённым ссылочным типом.

```C\#
public static Int32 Maximum(ref Int32 target, Int32 value)
{
    //targer может измениться в другом потоке
    Int32 currentValue = target;
    Int32 startValue, dediredValue;

    do {
        //Начальное значение текущей итерации
        startValue = curentValue;

        desiredValue = Math.Max(startValue, value);

        //Смысл того что происходит ниже: if (target == startValue) target = desiredValue
        //Метод возвращает значение, которое изменялось в методе, то есть фактическое состояние target
        //Если target и startValue не совпадают, то возвращается текущее состояние target
        //Если target и startValue совпадают, то target атомарно заменяется и возвращается предыдущее значение target
        currentValue = Interlocked.CompareExchange(ref target, desiredValue, startValue)

    } while (startValue != currentValue) // Если мы пытались изменить значение, 
    //не то которое ожидали, то пойти на след. итерацию

    return desiredValue;
}
```

### Блокировка с двойной проверкой

Блокировка с двойной проверкой - это паттерн для отложенной инициализации объекта.

В CLR вызов любого метода блокирования означает установку непреодолимого барьера на доступ к памяти: вся запись в переменные должна завершиться до этого барьера, а любое чтение переменных может начаться только после барьера. Это означает, как запрет перестановок операций во время выполнения, так и запрет кэширования переменных в регистрах процессора.

Проблема присваивания переменной вызова конструктора - переменной может быть присвоена ссылка до вызова самого конструктора, расписать.



