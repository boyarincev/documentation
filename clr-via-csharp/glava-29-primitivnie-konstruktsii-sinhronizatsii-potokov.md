# Глава 29. Примитивные конструкции синхронизации потоков

### Примитивные конструкции пользовательского режима и режима ядра

Конструкции пользовательского режима напрямую поддерживаются на аппаратном уровне - из-за этого они обладают намного большим быстродействием, чем конструкции режима ядра. Но из-за аппаратной поддержки виндовз во время блокировки потока не знает, что поток заблокирован и думает, что он продолжает свою обычную работу и продолжает выделять ему кванты времени для работы.

Примитивные конструкции режима ядра предоставляются операционной системой и требуют от потока вызова функций находящихся в ядре. Переход потока из пользовательского режима в режим ядра - это дорогая операция, требующая значительных ресурсов. Но плюс в том, что заблокированным таким образом поток усыпляется виндовз, до момента, когда необходимый ресурс будет освобождён.

Ситуация с бесконечно заблокированным потоком конструкцией пользовательского режима называется livelock.

Конструкцией режима ядра deadlock.

### Конструкции пользовательского режима

Система гарантирует атомарность чтения и записи только следующих типов: Ссылочных типов, char, \(S\)byte, \(U\)Int16, \(U\)Int32, \(U\)IntPtr, Single. При многопоточном доступе ко всем остальным типам необходима синхронизация потоков.

### Volatile-конструкции

C\# компилятор, JIT-компилятор, и даже процессор могут оптимизировать выполняемый код.

Эти оптимизации гарантируют сохранение назначения кода, но могут поменять способ выполнения которым это назначение достигается. И эти оптимизации не учитывают, что доступ к коду может осуществляться в многопоточном режиме.

#### Основная проблема, которую решает использование Volatile



Использование класса Volatile отключает оптимизации компиляторов и даже процессора \(_что именно отключает у процессора?_\).



