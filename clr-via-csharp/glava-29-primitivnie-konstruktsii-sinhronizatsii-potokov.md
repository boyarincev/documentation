# Глава 29. Примитивные конструкции синхронизации потоков

### Примитивные конструкции пользовательского режима и режима ядра

Конструкции пользовательского режима напрямую поддерживаются на аппаратном уровне - из-за этого они обладают намного большим быстродействием, чем конструкции режима ядра. Но из-за аппаратной поддержки виндовз во время блокировки потока не знает, что поток заблокирован и думает, что он продолжает свою обычную работу и продолжает выделять ему кванты времени для работы.

Примитивные конструкции режима ядра предоставляются операционной системой и требуют от потока вызова функций находящихся в ядре. Переход потока из пользовательского режима в режим ядра - это дорогая операция, требующая значительных ресурсов. Но плюс в том, что заблокированным таким образом поток усыпляется виндовз, до момента, когда необходимый ресурс будет освобождён.

Ситуация с бесконечно заблокированным потоком конструкцией пользовательского режима называется livelock.

Конструкцией режима ядра deadlock.

### Конструкции пользовательского режима

Система гарантирует атомарность чтения и записи только следующих типов: Ссылочных типов, char, \(S\)byte, \(U\)Int16, \(U\)Int32, \(U\)IntPtr, Single. При многопоточном доступе ко всем остальным типам необходима синхронизация потоков.

### Volatile-конструкции

C\# компилятор, JIT-компилятор, и даже процессор могут оптимизировать выполняемый код.

Эти оптимизации гарантируют сохранение назначения кода, но могут поменять способ выполнения которым это назначение достигается. И эти оптимизации не учитывают, что доступ к коду может осуществляться в многопоточном режиме.

Использование класса Volatile отключает оптимизации компиляторов и даже процессора \(_что именно отключает у процессора?_\).

#### Volatile.Write

Заставляет записать значение непосредственно в момент вызова. Более ранние загрузки и сохранения должны происходить до вызова этого метода.

#### Volatile.Read

Заставляет прочитать значение непосредственно в момент обращения. Более поздние загрузки и сохранения должны происходить после вызова этого метода.

#### Ситуация, когда можно использовать Volatile

Благодаря свойствам Volatile можно реализовать синхронизацию с использованием переменной или поля класса. С помощью Volatile нужно изменять состояние только синхронизационной переменной, такую переменную нужно рассматривать как флаг для каких-то действий со стороны других потоков. Если вы хотите установить синхронизационную переменную в определённое состояние, то вам необходима все действия вашего алгоритма произвести до установки этой переменной. Если вы читаете синхронизационную переменную, то вам необходимо все действия вашего алгоритма произвести после того, как вы прочитаете синхронизационную переменную и убедитесь, что она в нужном вам состоянии. Порядок действий в вашем коде \(то как вы пишите код\) остаётся таким же как если бы вы его писали для однопоточного кода, за одним лишь исключением, что состояние синхронизационной переменной вы читаете и записываете с помощью Volatile, что делает ваш код рабочим и для многопоточного окружения.

##### Общий смысл

Устанавливаем переменную в определённое состояние с помощью Volatile.Write\(ref obj\) после того как произведём все необходимые действия - это гарантирует, что все необходимые действия в этом методе были произведены до установки состояния переменной \(не было никаких оптимизационных перестановок\). Это состояние является сигналом готовности к чему-либо. Из другого потока читаем эту переменную с помощью Volatile.Read\(\) и если она в нужном нам состоянии, то производим какие-то действия - использование Volatile.Read\(\) гарантирует нам что значение будет читаться до того как будут производиться остальные действия в этом методе.

#### Поле с ключевым словом Volatile

Поле можно пометить ключевым словом Volatile и тогда доступ к нему будет осуществляться в виде волатильного чтения и записи.

Рихтер говорит, что в этом случае C\# и Jit-компиляторы не будут кэшировать значение этого поля в регистрах.

И приводит пример: mamount = mamount + m\_amount

В этом случае значение m\_amount будет читаться два раза в разные регистры, складываться и затем записываться в регистр, тогда как в обычном случае операция была произведена бы с помощью регистрового сдвига.

Непонятно в каких ещё случаях будут проблемы с регистрами. Любые чтения и записи будут осуществляться с помощью волатильного чтения и записи и если вы используете синхронизационную переменную не только для установки значения флага, но прозводите много каких-то ещё действий над ней, то вероятно в этом случае вы будете сталкиваться с проблемой отсутствия кэширования в регистрах.

### Interlocked-конструкции

Ставят барьер в памяти - записи переменных находящиеся перед этим методом будут выполняться до его выполнения. Чтения переменных, находящиеся после этого метода, будут выполняться после его выполнения.

#### Паттерн блокировки с использованием Interlocked



#### Универсальный Interlocked-паттерн



