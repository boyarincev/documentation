# Глава 29. Примитивные конструкции синхронизации потоков

### Примитивные конструкции пользовательского режима и режима ядра

Конструкции пользовательского режима напрямую поддерживаются на аппаратном уровне - из-за этого они обладают намного большим быстродействием, чем конструкции режима ядра. Но из-за аппаратной поддержки виндовз во время блокировки потока не знает, что поток заблокирован и думает, что он продолжает свою обычную работу и продолжает выделять ему кванты времени для работы.

Примитивные конструкции режима ядра предоставляются операционной системой и требуют от потока вызова функций находящихся в ядре. Переход потока из пользовательского режима в режим ядра - это дорогая операция, требующая значительных ресурсов. Но плюс в том, что заблокированным таким образом поток усыпляется виндовз, до момента, когда необходимый ресурс будет освобождён.

Ситуация с бесконечно заблокированным потоком конструкцией пользовательского режима называется livelock.

Конструкцией режима ядра deadlock.

### Конструкции пользовательского режима

Система гарантирует атомарность чтения и записи только следующих типов: Ссылочных типов, char, \(S\)byte, \(U\)Int16, \(U\)Int32, \(U\)IntPtr, Single. При многопоточном доступе ко всем остальным типам необходима синхронизация потоков.

### Volatile-конструкции

C\# компилятор, JIT-компилятор, и даже процессор могут оптимизировать выполняемый код.

Эти оптимизации гарантируют сохранение назначения кода, но могут поменять способ выполнения которым это назначение достигается. И эти оптимизации не учитывают, что доступ к коду может осуществляться в многопоточном режиме.

Использование класса Volatile отключает оптимизации компиляторов и даже процессора \(_что именно отключает у процессора?_\).

#### Volatile.Write

Заставляет записать значение непосредственно в момент вызова. Более ранние загрузки и сохранения должны происходить до вызова этого метода.

#### Volatile.Read

Заставляет прочитать значение непосредственно в момент обращения. Более поздние загрузки и сохранения должны происходить после вызова этого метода.

#### Ситуация, когда можно использовать Volatile

Благодаря свойствам Volatile можно реализовать синхронизацию с использованием переменной или поля класса. С помощью Volatile нужно изменять состояние только синхронизационной переменной, такую переменную нужно рассматривать как флаг для каких-то действий со стороны других потоков. Если вы хотите установить синхронизационную переменную в определённое состояние, то вам необходима все действия вашего алгоритма произвести до установки этой переменной. Если вы читаете синхронизационную переменную, то вам необходимо все действия вашего алгоритма произвести после того, как вы прочитаете синхронизационную переменную и убедитесь, что она в нужном вам состоянии. Порядок действий в вашем коде \(то как вы пишите код\) остаётся таким же как если бы вы его писали для однопоточного кода, за одним лишь исключением, что состояние синхронизационной переменной вы читаете и записываете с помощью Volatile, что делает ваш код рабочим и для многопоточного окружения.

##### Общий смысл

Устанавливаем переменную в определённое состояние с помощью Volatile.Write\(ref obj\) после того как произведём все необходимые действия - это гарантирует, что все необходимые действия в этом методе были произведены до установки состояния переменной \(не было никаких оптимизационных перестановок\). Это состояние является сигналом готовности к чему-либо. Из другого потока читаем эту переменную с помощью Volatile.Read\(\) и если она в нужном нам состоянии, то производим какие-то действия - использование Volatile.Read\(\) гарантирует нам что значение будет читаться до того как будут производиться остальные действия в этом методе.

#### Поле с ключевым словом Volatile

Поле можно пометить ключевым словом Volatile и тогда доступ к нему будет осуществляться в виде волатильного чтения и записи.

Рихтер говорит, что в этом случае C\# и Jit-компиляторы не будут кэшировать значение этого поля в регистрах.

И приводит пример: mamount = mamount + m\_amount

В этом случае значение m\_amount будет читаться два раза в разные регистры, складываться и затем записываться в регистр, тогда как в обычном случае операция была произведена бы с помощью регистрового сдвига.

Непонятно в каких ещё случаях будут проблемы с регистрами. Любые чтения и записи будут осуществляться с помощью волатильного чтения и записи и если вы используете синхронизационную переменную не только для установки значения флага, но прозводите много каких-то ещё действий над ней, то вероятно в этом случае вы будете сталкиваться с проблемой отсутствия кэширования в регистрах.

**Гораздо больше про volatile написано в этой статье: **[**https://habr.com/ru/post/130318/**](https://habr.com/ru/post/130318/)

Также в ней рассказывается про барьеры памяти и модель памяти.

### Interlocked-конструкции

Позволяют провести безопасную для многопочтоного доступа операцию чтения и/или записи. Ставят барьер в памяти - записи переменных находящиеся перед этим методом будут выполняться до его выполнения. Чтения переменных, находящиеся после этого метода, будут выполняться после его выполнения.

#### Паттерн блокировки с использованием Interlocked

Используется метод Compare.Exchange

У нас есть ресурс, на основе которого происходит блокировка. Допустим у него может быть два состояния true - заблокирован, false - не заблокирован.

```
private bool resourceLocked = false;

public void Enter()
{
    while(true)
    {
        //Мы зацикливаемся в цикле, пока не поменяем значение с false на true.
        //Если кто-то до нас поменяет значение, то условие не будет проходить.
        //Если мы меняем значение, то заходим в условие
        //Метод Exchange возвращает значение, которое было заменено.
        if(Interlocked.Exchange(ref resourceLocked, true) == false)
        {
            DoWork();
            break;
        }
    }
}
```

#### Универсальный Interlocked-паттерн

Interlocked содержит только несколько методов операций: Increment, Decrement.

Но существует паттерн используя который с помощью метода Interlocked.CompareExchange\(\) можно производить любые операции над типами: Int32, Int64, Single, Double, Object, и обобщённым ссылочным типом.

```C\#
public static Int32 Maximum(ref Int32 target, Int32 value)
{
    //targer может измениться в другом потоке
    Int32 currentValue = target;
    Int32 startValue, dediredValue;

    do {
        //Начальное значение текущей итерации
        startValue = curentValue;

        desiredValue = Math.Max(startValue, value);

        //Смысл того что происходит ниже: if (target == startValue) target = desiredValue
        //Метод возвращает значение, которое изменялось в методе, то есть фактическое состояние target
        //Если target и startValue не совпадают, то возвращается текущее состояние target
        //Если target и startValue совпадают, то target атомарно заменяется и возвращается предыдущее значение target
        currentValue = Interlocked.CompareExchange(ref target, desiredValue, startValue)

    } while (startValue != currentValue) // Если мы пытались изменить значение, 
    //не то которое ожидали, то пойти на след. итерацию

    return desiredValue;
}
```

### Блокировка с двойной проверкой

Блокировка с двойной проверкой - это паттерн для отложенной инициализации объекта \(объект будет инициализироваться только при первичном доступе\), поддерживающий многопоточный доступ.

```c\#
internal sealed class Singleton {
    private static readonly Object s_lock = new Object();

    private static Singleton s_value = null;

    private Singleton() {

    }

    public static Singleton GetSingleton() {
        if (s_value != null) {
            return s_value;
        }

        Monitor.Enter(s_lock);

        if (s_value == null) {
            //Используем временную переменную, чтобы не было проблемы с порядком присваивания ссылки и вызовом конструктора
            //Из альтернатив сделать поле s_value волатильным
            Singleton temp = new Singleton();

            Volatile.Write(ref s_value, temp);
        }

        Monitor.Exit(s_lock);

        return s_value;
    }
}
```

**В CLR вызов любого метода блокирования означает установку непреодолимого барьера на доступ к памяти: вся запись в переменные должна завершиться до этого барьера, а любое чтение переменных может начаться только после барьера. Это означает, как запрет перестановок операций во время выполнения, так и запрет кэширования переменных в регистрах процессора.**

Проблема присваивания переменной с одновременным вызовом конструктора - переменной может быть присвоена ссылка до вызова самого конструктора, поэтому другие потоки могут решить, что объект уже готов к использованию, так как ссылка больше не null и попытаться начать с ним работать.

_Здесь появляется новая информация о свойстве полей помеченных volatile - если поле которому присваивается такое значение volatile, то ситуация, когда полю сначала присваивается ссылка, а потом только происходит инициализация памяти по этой ссылке - исключена._

#### Альтернативы

1. Инициализация в статическом конструкторе
2. Использование Interlocked.CompareExchange\(\) вместо второй блокировки - если s\_\_value по прежнему null - то значение из временной переменной записывается в поле s\_\_value, если же кто-то первый записал, то замены не происходит.

При использовании Lazy, в качестве параметра мы можем передать какой механизм многопоточного доступа он будет использовать и можно выбрать использовать блокировку с двойной проверкой или Interlocked.CompareExchange\(\).

### Паттерн условной переменной

Паттерн, который позволяет проверить сложное условие в многопоточном окружении - сложное условие - это значит нужно проверить состояние многих переменных, да и вообще что угодно.

Реализовано с помощью Monitor.Wait \(поток засыпает\) и Monitor.Pulsе \(разбудить заснувший поток\).

