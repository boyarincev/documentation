# Глава 1. Модель выполнения кода в среде CLR

## Компиляция исходного кода у управляемые модули

Результатом компиляции является _управляемый модуль -_ стандартный переносимый исполняемый \(portable executable\) файл 32-разрядной \(PE\) или 64-разрядной \(PE+\) Windows, который требует для своего выполнения CLR.

Части управляемого модуля

| Часть | Описание |
| :--- | :--- |
| Заголовок PE32 или PE32+ | Стандартный заголовок PE-файла |
| Заголовок CLR | Информация интерпретируемая CLR.  Включает версию CLR, метку метаданных MethodDef точки входа в управляемый модуль \(метод Main\), местоположение метаданных модуля, ресурсов, строго имени и т.д. |
| Метаданные | Таблицы метаданных. Два основных типа - таблицы описывающие типы данных и их члены, определённые в исходном коде, и таблицы описывающие типы данных и их члены, на которые есть ссылки в исходном коде. |
| IL код | Код созданный компилятором при компиляции. |

## Объединение управляемых модулей в сборку

CLR на самом деле работает не с управляемыми модулями, а со сборками.

**И вообще оказывается, что управляемый модуль - это файл исходного кода.**

Сборка это:

1. Логическая группировка одного или нескольких управляемых модулей \(**файлов**\)
2. Наименьшая единица многократного использования
3. Абстрактное понятие :\)
4. Концептуальное понятие обозначающие объединение группы файлов в единую сущность

То есть по-настоящему, в PE32 файле находится не управляемый модуль, а сборка.

Сборка содержит Манифест, который описывает содержимое сборки \(это тоже набор таблиц метаданных описывающих файлы, которые входят в сборку\).

По умолчанию компилятор сам выполняет работу по преобразованию созданного управляемого модуля в сборку и создает манифест в котором указывает, что сборка состоит из одного управляемого модуля \(**файла**\).

Модули сборки содержат сведения о других сборках, на которые они ссылаются.

## Загрузка CLR

При запуске исполняемого файла Windows анализирует заголовок EXE-файла для определения того, какое именно адресное пространство необходимо для его работы - 32 или 64-разрядное - определяет тип процесса. Загружает в адресное пространство процесса соответствующую версию библиотеки MSCorEE.dll. Далее основной поток вызывает определённый в библиотеке MSCorEE.dll, который инициализирует CLR, загружает сборку EXE, а затем вызывает её метод Main.

## Исполнение кода сборки \(первый вызов метода Main\)

1. Непосредственно перед исполнение метода Main среда CLR находит все типы данных, на которые ссылается программный код метода Main - используя таблицы метаданных.
2. Допустим в методе используется только тип Console. Среда находит таблицу где находятся методы типа Console. Каждая запись в этой таблице содержит адрес, по которому находится реализация метода. При инициализации этой структуры адресом каждого метода становится специальный внутренний метод JitCompiler.
3. При первом обращении к методу \(имеется в виду Console.WriteLine находящийся в примере метода Main\) вызывается функция JitCompiler - она отвечает за компиляцию метода из IL-кода в машинные команды процессора на котором исполняется программа. Так как код компилируется непосредственно перед выполнение этот компонент CLR называют Jit-компилятором.
4. Метод JitCompiler находит в метаданных адрес по которому находится IL-код вызываемого метода, извлекает его, выделяет блок памяти для скомпилированного в машинные команды метода, компилириует IL-код в машинные команды и сохраняет в выделенный блок памяти, изменяет точку входа в метод в метаданных на адрес блока памяти в который только что сохранили откомпилированный метод, передаёт управление машинному коду скомпилированного метода.

