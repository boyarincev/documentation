---
book: 'Clr via C#'
---

# Глава 22. Хостинг CLR и домены приложений

### Вопросы

1. А в дотнеткоре есть хостинг CLR ? Как теперь работает в линуксе?
2. Что такое com-сервер?
3. Что значит загрузить сборку в процесс?
4. А без доменов как жить в линуксе?
5. Что такое куча загрузчика?

### Хостинг CLR

Это возможность запускать CLR в процессе своего неуправляемого приложения и управлять этой CLR.

#### Зачем это нужно

* Создание программ оболочек над .NET
* Переписать часть своего приложения на управляемый код
* Возможность дать сторонник разработчикам писать расширения для своего приложения на .NET

#### Технические подробности

* CLR работаем как Com-сервер \(**теперь уже нет**\) содержащийся в CLR
* Любое виндовз приложение может стать хостингом CLR
* Дальше расписаны грязные подробности как загрузить CLR в свой процесс \(Суть в том, что DLL с CLR грузится в итоге в этот процесс\)

### Домены приложений

В ходе инициализации ком-сервера CLR создаёт домен приложений - это логический контейнер для сборок.

Первый домен приложений в процессе называется основным и он может быть уничтожен только с процессом.

Дополнительные домены могуть быть созданы хостом, используя методы неуправляемого com-интерфейса или из управляемого кода.

Цель дополнительных доменов - изоляция исполняемого кода.

#### Свойства доменов приложений

* Объекты созданные в одном домене недоступны для прямого доступа в другом домене
* CLR не поддерживает выгрузку из процесса отдельных сборок, однако можно выгрузить домен и вместе с ним все используемые им сборки
* Создаваемому домену можно настраивать разрешения которые будут у используемых им сборок
* Можно определить индивидуальные настройк
* Нет жёстких ограничений количество доменов в процессе

#### Домен и сборки

Сборки грузятся в каждый домен независимо, даже если сборку одну и ту же нужно загрузить в несколько доменов одного процесса.

В каждом домене есть своя куча загрузчика, ведущая учёт обращений к типам с момента создания домена.

В ней каждому типу соответствует таблица методов, в строках которой указатели на код метода.

Если этот метод уже хоть раз исполнялся, его код скомпилирован Джит-компилятороом в машинный код.

**Машинный код методов компилируется независимо в каждом домене**

Сборка MsCorLib.dll загружается автоматически CLR при инициализации и используется всеми доменами совместно - она не привязана к какому-то определённому домену.

#### Доступ к объектам из разных доменов

Доступ возможен

1. По ссылке - будет создан прокси-объект через, который будет осуществляться доступ. Для этого тип должен наследоваться от MarshalByRefObject.
2. По значению - объект может быть скопирован, для этого он должен быть помечен, как сериализуемый \(Serializable атрибут\)

В ином случае будет выкинуто NonMarshalableType исключение

```C\#
var appDomain = AppDomain.CreateDomain();
var typeFromDomain = appDomain.CreateInstanceAndUnwrap("assemblyFullName", "TypeName");
```

Поток не привязан к домену, если вызывается код из другого домена, то это происходит синхронно и поток просто продолжает выполнение кода, но просто уже в другом домене.

#### Выгрузка домена

```C\#
appDomain.Unload();
```

1. В процессе останавливаются все процессы выполняющие или когда-либо выполнявшие управляемый код.
2. CLR находит потоки выполняющие сейчас или которые могут вернуться к исполнению кода выгружаемого домена. Находят по стекам потоков.
3. CLR заставляет все такие потоки сгенерировать исключение ThreadAbortException.
   1. Раскрутившись до конца стека потока, исключение проглатывается CLR, поток завершается, а процесс продолжает работать.
   2. Есть области кода, для которых CLR ждёт пока поток их покинет прежде чем заставить его сгенерировать исключение.
4. Все прокси объектов для выгружаемого домена узнают о уничтожении объектов на которые они ссылаются - CLR их находит для этого.
5. Уборка мусора
6. Потоки возобновляют свою работу

#### Мониторинг доменов

У домена можно мониторить сколько процессорного времени он потратил и сколько памяти занимает.

### Нетривиальное управление хостингом

В главе рассказываются некоторые особенности управления хостингом CLR.

Самое интересное - это пример как из хоста или из основного домена остановить выполнение кода в другом домене, если он слишком долго выполняется.

1. Вызываем метод Abort тип Thread \(или экземпляра?\)
2. Это будет вынуждать CLR остановить поток из пула и выдать исключение ThreadAbortException \(метода Abort асинхронный - он только выставит флаг в потоке\)

Исключение будет выкидываться, если поток в данный момент не выполняет код в критической области.

Чтобы указать, что сейчас выполняется код в критической области:

`Thread.BeginCriticalRegion()`

`Thread.EndCriticalRegion()`

Нюансы

Если перехватить исключение ThreadAbortException, то после блока catch CLR снова его сгенерирует

Чтобы оно не выкидывалось у потока нужно вызвать Thread.ResetAbort\(\) - но вызвать его можно только если у твоего домена \(домена который будет его вызывать\) есть право это сделать \(SecurityPermission с флагом ControlThread\).

Если перехватить ThreadAbortException и выкинуть друго - то оно будет раскручиваться вверх, но если его перехватит кто-то и ничего взамен не выкинет, то CLR снова выкинет ThreadAbortException.

В общем процесс работы такой:

Нужно раскрутить поток \(вызвав метод Abort\), до того момента, пока он не покинет домен в котором код слишком долго выполняется и не выйдет в основной домен. Как только он покинет домен у потока нужно вызвать ResetAbort и прекратить раскрутку дальше.

