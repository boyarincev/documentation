# Глава 26. Потоки исполнения

Процесс - набор ресурсов выделяемых каждому приложению. Каждому процессу выделяется виртуальное адресное пространство.

Поток - концепция виртуализации процессора.

### Ресурсоёмкость потоков \(структура потока\)

#### Thread Kernel Object \(объект ядра потока\)

Содержит какую-то инфу, пока неизвестно какую.

Также содержит Контекст потока - блок памяти с набором регистров процессора \(для каждого процессора будет своя\)

#### Thread Environment Block \(TEB\)

Занимает одну страницу памяти.

Содержит

* Заголовок цепочки обработки исключений \(при каждом входе в блок try вставляется новая запись, при выходе из блока try удаляется запись\)
* Локальное хранилище данных поток \(_что там хранится?_\)
* И что-то для видеоподсистемы

#### Стек пользовательского режима \(user-mode stack\)

Стек приложения. По умолчанию на каждый стек пользовательского режима выделяется 1 мегабайт \(_инфа ещё актуальна?_\) и **добавляется физическая память по мене необходимости при росте стека**.

#### Стек режима ядра \(kernel-mode stack\)

Используется, когда код приложения передаёт аргументы в функцию операционной системы. Windows копирует передаваемые аргументы в целях безопасности в стек режима ядра, где к ним уже не имеет доступа код приложения. В 32 битной версии занимает 12 килобайт, в 64 битной - 24 килобайта.

#### Уведомления о создании и завершении потоков

При создании и завершении потоков у всех DLL-библиотек загруженных в процесс вызывается метод DLLMain.

**Библиотеки C\# не имеют метода DLLMain - поэтому для них нет накладных расходов на вызов метода. У неуправляемых библиотек этот вызов тоже можно отключить.**

### Смена потока выполнения

При смене потока происходит сохранение состояния регистров процессора в поток \(в ядро потока\), который прекращает выполнение и регистры заполняются инфой из потока, который начинает выполнение.

### CLR и Windows потоки

Изначально предполагалось, что это будут разные потоки, но затем было принято решение, что они должны быть одним и тем же. Но в API уже были добавлены названия, из-за которых может возникать мнение, что CLR-потоки какая-то отдельная концепция.

### Планирование и приоритеты потоков

Каждый поток имеет уровень приоритета от 0 до 31.

При выборе потока для исполнения сперва рассматриваются потоки с самым высоким приоритетом, при наличии в очереди потоков с меньшим приоритетом система никогда не передаст ему управление, пока есть поток с более высоким приоритетом.

Если при выполнении низко приоритетного потока появляется потом с большим приоритетом, управление немедленно передаётся ему, даже не дожидаясь окончания такта.

Приоритет задаётся с помощью класса приоритета для процесса и относительного приоритета потока

#### Класс приоритета процесса

* Idle
* Below Normal
* Normal
* Above Normal
* High
* Realtime

Класс приоритета процесса обычно зависит от того какой процесс запускает его. Например, Проводник назначает всем своим потокам класс Normal. Так как процесс не принадлежит управляемым приложением, так как они запускаются в домене, они не могут менять свой класс приоритета.

#### Относительный приоритет потока

* Idle
* Lowest
* Below Normal
* Normal
* Above Normal
* Highest
* Time-Critical

Приложение может менять относительный приоритет потока с помощью свойства Priority класса Thread. Приложение не может выбрать приоритеты Idle и Time-Critical их CLR резервирует для себя \(с приоритетом Time-Critical работает поток финализации - _вот что имелось ввиду под высоко приоритетный поток!_\).

### Фоновые и Активные потоки

Когда в процессе не остаётся Активных потоков, все фоновые завершаются, завершение фоновых потоков при этом происходит немедленно и без выдачи исключений.

* Тип потока можо менять.
* Основной поток приложения и потоки созданные явно с помощью Thread являются активными по умолчанию
* Потоки из пула потоков по умолчанию являются фоновыми



