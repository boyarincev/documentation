---
book: 'Clr via C#'
---

# Глава 21. Уборка мусора

### Оставшиеся вопросы

1. Что такое рабочий набор приложения?

### Что происходит при вызове new

1. Подсчитывается количество байтов для размещения полей типа и унаследованных полей.
2. Прибавляется размер системных полей.
3. Проверяется хватает ли зарезервированной области памяти для объекта \(при необходимости резервируется новая память\). Если памяти хватает, выделяется память начиная с адреса на который указывает NextObjPth.

### Устройство кучи

Куча - это зарезервированная область памяти \(резервируется при инициализации процесса\) и указатель, который Рихтер называет NextObjPtr - указатель на место, где память будет выделяться для следующего объекта.

По мере заполнения кучи выделяются новые области памяти, вплоть до того как не будет исчерпан размер всего адресного пространства процесса.

### Алгоритм уборки мусора

Это упрощённое описание алгоритма.

1. При заполнении места выделенного для поколения 0 начинается уборка мусора.
2. Приостанавливаются все потоки приложения.
3. Начинается фаза маркировки
   1. Все объекты в куче помечаются для удаления
   2. Проверяются все достижимые для приложения объекты и помечаются как активные
4. Начинается фаза сжатия
   1. CLR перемещает в куче к началу все достижимые объекты \(это сокращает рабочий набор приложения\)
   2. Адреса ссылок на сдвинутые объекты обновляются, так чтобы объекты продолжали быть достижимыми
   3. NextObjPtr обновляется и указывает на следующий адрес за последним объектом в куче.
5. Если место в куче не удалось освободить, а память процесса исчерпана, то вылетает OutOfMemoryException.

Рихтер определяет корни так - это все переменные ссылочного типа \(а не точки, которые доступны для приложения\). На данный момент не понятно, как ищутся корни.

### Уборка мусора и отладка

Рассказывается о особенностях работы уборки мусора в режимах Debug и Release.

В Release уборка мусора очистит все корни, которые уже пройдены в методе и больше использоваться не будут.

В Debug никакие корни метода не будут удаляться, пока метод не будет завершён.

Приводится пример c timer и callback. callback вызывает явную уборку мусора и в релизе callback будет вызван всего один раз, так как при его вызове объект таймер будет удалён и больше не будет вызывать callback.

### Поколения

* На данный момент объекты могут относиться к одному из трёх поколений
* Для каждого поколения CLR выбирает пороговый размер в куче

**Общее описание алгоритма:**

**Когда прeвышен размер выделенный для поколений, в этих поколениях производится уборка мусора, но точный алгоритм не ясен \(с точным порядком действий\) и дальше в описании алгоритма могут быть ошибки.**

* При создании нового объекта сборщик мусора смотрит не был ли превышен размер выделенный для объектов в поколении 0.

* Если размер для поколения 0 превышен, то смотрится не превышен ли размер в поколениях 1 и 2

* Если не превышен, то мусор собирается только в поколении 0

* Если превышен, то мусор собирается и в этих поколениях \(то есть если после уборки мусора в 0 или 1 поколении размер будет превышен в старшем поколении, то это будет известно только при следующей уборке мусора\)

* Уборщик мусора изменяет свой поведение в зависимости от ситуации - он может увеличивать или уменьшать размер поколений.

**То есть очистка в поколениях 1 или 2 происходит только когда есть превышение и соответственно очистка в поколении 0.**

Оптимизации уборки мусора:

* Объекты лежащие в вышестоящих поколениях не проверяются \(это само собой понятно\)
* Если корень ссылается не объект в вышестоящем поколении эти ссылки игнорируются и граф по ним не строится
  * Для того чтобы отследить момент, когда объекту из старшего поколения присваивается ссылка на объект из младшего поколения - существует специальный механизм \(похоже этот механизм тупо отслеживает все изменения объектов в 1 и 2 поколении\)

**Специальный механизм отслеживания ссылок появившиеся из старшего поколения на младшее**

Отслеживается какие объекты изменялись с последней уборки мусора и такие объекты проверяются - нет ли у них ссылок на младшее поколение.

Джит-компилятор создаёт специальный код, когда модифицируется ссылочное поле внутри объекта. Туда входит проверка не принадлежит ли этот объект к 1 или 2 поколению. В случае если принадлежит, устанавливается бит в специальную таблицу - эта таблица карта с адресами кучи \(по одному биту для каждого 128-байтного диапазонаа данных в куче\). В начале следующей уборки мусора из таблицы видно, какие объекты менялись с прошлой уборки. После уборки мусора всем битам таблицы присваиваются нулевые значения. Из-за встраивания этого метода в приложении уменьшается производительность.

#### Запуск уборки мусора

1. Статический метод `System.GC.Collect()`
2. Windows не хватает памяти \(CLR подписано на соответствующие события\)
3. Выгрузка домена
4. CLR завершает работу

#### Большие объекты

Объекты размером больше 85 килобайт \(на данный момент\) считаются большими объектами и с ними CLR работает особенным образом

* Они размещаются в специальном адресном пространстве
* Они не подвергаются сжатию \(на данный момент\) - то есть не перемещаются в памяти, когда какой-то объект очищается - это может привести к дефрагментации памяти и её нехватке и выдаче исключения OutOfMemoryException.
* Считаются поколением 2 и соответственно их очистка происходит только когда запускается очистка памяти для поколения 2

#### Режимы уборки мусора

Два основных режима уборки мусора:

1. Режим рабочей станции - оптимизирован для минимизации времени приостановки потоков приложения, чтобы не раздражать пользователя. Также он старается использовать как можно меньше процессорного времени, так как предполагает, что на компьютере работают другие приложения.
2. Режим работы сервера - предполагает, что на компьютере ничего больше не запущено, поэтому все ресурсы можно бросить на очистку памяти. В этом режиме куча делится на части и каждой части выделяется поток, который с ней работает, изначально уборщик мусора использует один поток на один процессор.

По умолчанию приложения запускаются в режиме рабочей станции с режимом параллельной уборкой мусора. Серверные приложения могут требовать загрузку в режиме сервера \(_точно не ясно они это сами делают или от пользователя это требуют?_\). Если серверное приложение запускается на однопроцессорной машине, то оно работает в режиме рабочей станции.

В кофиге можно указать, в каком режиме запускать приложение - и тогда любое приложение можно запустить в серверном режиме.

**Изменить режим можно только перезапустив процесс!**

Узнать текущий режим:

```
System.Runtime.GCSettings.IsServerGC
```

```XML
<configuration>
    <runtime>
        <scServer enabled="true" />
    </runtime>
</configuration>
```

Существуют два подрежим:

* Параллельная уборка мусора - используется по-умолчанию
* Не параллельная уборка мусора

##### Параллельная уборка мусора

В этом режиме существует специальный поток, который ищет объекты для очистки в фоне.

Алгоритм:

1. Когда превышен размер поколения 0, происходит приостановка всех потоков приложения, уборщик мусора просматривает поколения 1 и 2 и если превышение находится только в поколениях 0 и/или 1 то всё происходит как обычно.
2. Но если превышение в поколении 2, то уборщик мусора увеличивает размер поколения 0, чтобы была возможность создать этот объект из-за которого возникает превышение и возобновляет работу потоков и позволяет создать объект из-за которого у нас возникает превышение в поколении 0
3. Тут в игру вступает фоновый поток, который ищет объекты, которые нужно очистить \(похоже, что ищет во всех поколениях, где нужна очистка, в том числе и в том поколении, размер которого увеличивался на предыдущем шаге\)
4. После того как фоновый поток проверит все объекты, все потоки приложения снова приостанавливаются и возможны два варианта развития событий \(_уборщик мусора как-то сам решает?_\)
   1. Происходит дефрагментация памяти, правка ссылок на корни - это происходит быстрее, чем обычная уборка мусора, так как объекты для удаления заранее найдены
   2. Дефрагментация не происходит \(_а объекты из памяти не очищаются? их место другие объекты не занимают? зачем тогда искать их было?_\) - из-за этого увеличивается рабочий набор приложения.

В конфигурационном файле можно запретить использовать параллельный режим уборки мусора

```
<configuration>
    <runtime>
        <scConcurrent enabled="false" />
    </runtime>
</configuration>
```

##### Контроль уборки мусора в рантайме

Есть возможность контролировать работу уборщика мусора, без перезапуска приложения, это делается с помощью свойства `GCSettings.GCLatencyMode`

|  |  |
| :--- | :--- |
| Batch \(используется по умолчанию для серверного режима\) | Отключает параллельную уборку мусора |
| Interactive \(используется по умолчанию для режима рабочей станции\) | Включает параллельную уборку мусора |
| LowLatency | Отключает уборку мусора в поколении 2. Используется для каких-то операций, для которых важно время выполнения, например, анимация. Предполагается, что он включается на какое-то короткое время, затем переход в другой режим. Уборка мусора в этом режиме в поколении 2 всё-таки будет произведена, при вызове GC.Collect\(\) и если Windows будет не хватать памяти |
| SustainedLowLatency | Блокирующая \(_что значит блокирующая?_\) уборка мусора в поколении 2 запрещена при наличии свободной памяти. |

#### Программное управление уборщиком мусора

##### Уборка мусора методом `Collect() принимает несколько параметров.`

```
GC.Collect(Int32 generation, GCCollectionMode mode, Boolean blocking)
```

generation - в какоп поколении произвести уборку мусора \(_похоже, что в любом случае и во всем более младших поколениях тоже в этом случае_\).

mode - три варианта. Default, Forced и Optimized.

* Default - тоже что и Forced.

* Forced - произвести уборку мусора в переданном поколении и в более младших.

* Optimized - поизвести уборку мусора, только если это даст качественный конечный результат \(освобождение памяти, уменьшение фрагментации\).

blocking - не параллельная или параллельная уборка мусора.

##### События уборки мусора

Можно подписаться на события уборки мусора с помощью класса `GC`

И вызывая методы GC например отложить уборку мусора или прервать её и ещё наверняка многое сделать.

#### Мониторинг использования памяти приложением

В систему устанавливаются счётчики производительности и можно следить за уборкой мусора с помощью них. Для анализа использования памяти и производительности приложения можно использовать PerfView.

### Освобождение ресурсов при помощи механизма финализации

#### Общая информация

Если объект содержит системные ресурсы \(дескрипторы файлов, объекты ядра\), то недостаточно уничтожить объект в памяти, нужно сказать системе, что системный ресурс освободился. Для этого предназначен метод Finalize типа Object.

Чтобы переопределить его существует специальный синтаксис

```
internal sealed class SomeType {
    ~SomeType(){

    }
}
```

Если у объекта переопределён метод Finalize, то поведение сборщика мусора меняется. После того, как такой объект уборщик мусора считает неиспользуемым и подлежащим удалению, он ставится в очередь на финализацию, которую выполняет специальный поток финализации. Также такой объект переживает текущую уборку мусора, и его поколение повышается, то есть этот объект будет удалён из памяти, после того как будет производится очистка памяти того поколения, к которому он теперь будет принадлежать.

Каким-то образом уборщик мусора знает, вызывался ли уже для этого объекта метод финализации и завершился ли он и только после этого освобождает память занимаемую этим объектом.

Следует учитывать, что не просто сам объект подлежащий финализации повышает своё поколение, но и весь граф объектов, на которые он ссылается.

Ещё некоторые интересные моменты:

* Неизвестно когда будет вызван финализатор объекта - это зависит от того, когда уборщик мусора найдёт этот объект \(а когда он найдёт его зависит от того к какому поколению принадлежит этот объект\) и от того, когда до этого объекта доберется поток, который обрабатывает очередь финализации
* Нет гарантии порядка вызовов объектов в очереди финализации, поэтому финализируемый объект не должен ссылаться на другие финализируемые объекты, так как эти объекты могут быть уже финализированы и даже уничтожены из памяти
* Если финализатор выкинет исключение, то завершится весь процесс
* Если финализатор зависнет \(например в бескнечном цикле или в блокировке в ожидании другого объекта\), то похоже поток финализации в нём навечно застрянет

Так как освобождение системных ресурсов с помощью финализаторов вещь накладная, Microsoft сама использует другой механизм и Рихтер рекомендует нам тоже его использовать.

#### SafeHandle

Существует специальный класс `System.Runtime.InteropServices.SafeHandle` при наследовании от которого можно произвести освобождение системных ресурсов во время уборки мусора и не использовать финализацию, Рихтер рекомендует использовать его.

##### Механизм работы

Этот класс наследует IDisposable и CriticalFinalizeObject.

Этот класс обмазался IntPtr'ами.

Фактически механизм освобождения ресурса делается в методе Dispose, который вызывается обычным для .NET образом, также в нём есть финализатор, который предполагается вызывать, когда что-то пошло не так.

Для классов, которые наследуются от CriticalFinalizeObject у CLR есть несколько особенностей поведения:

1. При вызове конструктора таких классов у них сразу же компилируются все методы, поэтому невозможна ситуация, когда финализация не будет произведена, если у процесса не хватит памяти для компиляции методов
2. Финализаторы таких объектов вызываются после финализаторов других объектов - поэтому в финализаторах обычных объектов можно не боятся обращаться к объектам наследуемым от CriticalFinalizeObject.
3. Финализаторы таких объектов вызываются если домен аварийно завершил свою работу

Также есть пара оптимизаций относящихся к самому SafeHanlde

1. Можно из вызовов методов неуправляемого кода возвращать сразу SafeHandle и в этом случае есть гарантия, что объект SafeHandle будет создан и ему будет присвоен дескриптор ресурса \(если бы мы из неуправляемого кода получали дескриптор, а затем руками создавали SafeHandle, то эта операция могла быть прервана, например, ThreadAbortException и контроль над системным ресурсом был бы утерян\)
2. Что-то связанное с безопасностью и контролем ссылок - непонятно как работает.

Итог:

Дополнительные гарантии безопасности - да, но вообще принципиально не отличается от использования Dispose и GC.SuppressFinalize. И вообще возникает впечатление, что его нужно использовать когда работаешь с неуправляемым кодом и дескрипторами \(IntPtr'ами\) напрямую, а не когда работаешь с управляемыми ресурсами, которые работают внутри с неуправляемыми.

#### Типы использующие системные ресурсы

Тут рассказано про FileStream и про то что внутри он использует тип SafeFileHandle для работы с дескриптором файла. Ещё про то что он имеет буфер, который сбрасыватся в файл при dispos'е или при финализации.

#### Интересные аспекты зависимостей

А тут рассказано про StreamWriter, который умеет писать строки и который может использовать FileStream, который умеет использовать только байты.

Интересный аспект - это то что у StreamWriter тоже есть буфер, но если бы этот буфер сбрасывался при финализации, то могла бы возникнуть ситуация, когда экземпляр FileStream бы уже прошёл финализацию \(так как порядок файлов в списке финализации не гарантирова\), а StreamWriter ещё нет и попытался бы использовать уже финализированный FileStream. Решение этой проблемы, которое придумало Microsoft - это отсутствие финализатора у StreamWriter и потеря буфера в случае, если никто не вызовёт на нём Dispose.

#### Другие возможности уборщика мусора для работы с системными ресурсами

Когда управляемая оболочка объекта занимает относительно небольшое количество памяти, а неуправляемый ресурс большое \(пример - растровое изображение\), уборщик мусора не будет понимать адекватную картину с текущим расходом памяти.

Для этого можно использовать методы

```
GC.AddMemoryPressure(Int32 bytesAllocated);
GC.RemoveMemoryPressure(Int32 bytesAllocated);
```

Эти методы говорят, сколько на самом деле занимает создаваемый объект.

В ситуациях, когда неуправляемый ресурс ограничен и нельзя выделить больше "экземпляров" - можно использовать класс HandleCollector, который будет следить за выделениями и вызывать уборку мусора, когда выделено ресурсов будет больше допустимого.

_**Этот класс ничего не гарантирует - он просто вызывает уборку мусора, когда выделено больше ресурсов допустимого, но если другие ресурсы ещё используются, то уборка мусора ничего не даст.**_

Как использовать:

* Экземпляр этого класса следует использовать внутри класса, который является оболочкой для неуправляемого ресурса. 
* В него передается количество допустимых выделений ресурса и при каждом создании нового экземпляра, нужно вызывать метод Add объекта HandleCollecror
* Во время Dispose и финализации, нужно вызывать метод Remove \(у Рихтера в примере, почему-то только финализаторы добавлены, возможно чтобы пример не раздувать\)
* Так как объект HandleCollector считает количество созданных экземпляров ресурса, то чтобы с ним работать нужно сделать его статическим полем

#### Внутренняя реализация финализации

Перед вызовом конструктора объекта, если он содержит финализатор, то ссылка на объект помещается в список финализации \(finalization list\).

Во время уборки мусора, на стадии маркировки, если объект  после поиска в корнях и их маркировки, остался не промаркирован и он находится в списке финализации, то запись о нём удалется из списка финализации и помещается в очередь финализации \(freachable queue\).

Необходимо чтобы объекты в очереди финализации не подлежали уборке мусора, поэтому они считаются корнями и маркируются как достижимые \(весь граф объектов на которые они ссылаются\).

Соотвественно они не подлежат уборке мусора и их поколение повышается, следующий раз они будут подлежать проверке когда будет осуществляться уборка мусора в их новом поколении.

В системе существует специальный высокопроизводительный поток \(_не знаю что это значит_\), который следит за очередью финализации и как только там появляются объекты вызывает из финализаторы и удаляет из очереди.

_На данный момент высокопроизводительный поток один, но в будущем их может быть много, поэтому не стоит рассчитывать на какой-то порядок вызовов финализаторов объектов._

В следующий раз, когда будет производиться уборка мусора, объект не будет найден ни в списке финализации ни в очереди финализации \(если поток финализации успеет до этого момента вызвать их финализатор и удалить их из очереди\), поэтому он не будет промаркирован и будет удалён.

### Мониторинг и контроль времени жизни объектов



