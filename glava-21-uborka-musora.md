---
book: 'Clr via C#'
---

# Глава 21. Уборка мусора

### Оставшиеся вопросы

1. Что такое рабочий набор приложения?

### Что происходит при вызове new

1. Подсчитывается количество байтов для размещения полей типа и унаследованных полей.
2. Прибавляется размер системных полей.
3. Проверяется хватает ли зарезервированной области памяти для объекта \(при необходимости резервируется новая память\). Если памяти хватает, выделяется память начиная с адреса на который указывает NextObjPth.

### Устройство кучи

Куча - это зарезервированная область памяти \(резервируется при инициализации процесса\) и указатель, который Рихтер называет NextObjPtr - указатель на место, где память будет выделяться для следующего объекта.

По мере заполнения кучи выделяются новые области памяти, вплоть до того как не будет исчерпан размер всего адресного пространства процесса.

### Алгоритм уборки мусора

Это упрощённое описание алгоритма.

1. При заполнении места выделенного для поколения 0 начинается уборка мусора.
2. Приостанавливаются все потоки приложения.
3. Начинается фаза маркировки
   1. Все объекты в куче помечаются для удаления
   2. Проверяются все достижимые для приложения объекты и помечаются как активные
4. Начинается фаза сжатия
   1. CLR перемещает в куче к началу все достижимые объекты \(это сокращает рабочий набор приложения\)
   2. Адреса ссылок на сдвинутые объекты обновляются, так чтобы объекты продолжали быть достижимыми
   3. NextObjPtr обновляется и указывает на следующий адрес за последним объектом в куче.
5. Если место в куче не удалось освободить, а память процесса исчерпана, то вылетает OutOfMemoryException.

Рихтер определяет корни так - это все переменные ссылочного типа \(а не точки, которые доступны для приложения\). На данный момент не понятно, как ищутся корни.

### Уборка мусора и отладка

Рассказывается о особенностях работы уборки мусора в режимах Debug и Release.

В Release уборка мусора очистит все корни, которые уже пройдены в методе и больше использоваться не будут.

В Debug никакие корни метода не будут удаляться, пока метод не будет завершён.

Приводится пример c timer и callback. callback вызывает явную уборку мусора и в релизе callback будет вызван всего один раз, так как при его вызове объект таймер будет удалён и больше не будет вызывать callback.

### Поколения

* На данный момент объекты могут относиться к одному из трёх поколений
* Для каждого поколения CLR выбирает пороговый размер в куче



