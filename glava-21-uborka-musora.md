---
book: 'Clr via C#'
---

# Глава 21. Уборка мусора

### Оставшиеся вопросы

1. Что такое рабочий набор приложения?

### Что происходит при вызове new

1. Подсчитывается количество байтов для размещения полей типа и унаследованных полей.
2. Прибавляется размер системных полей.
3. Проверяется хватает ли зарезервированной области памяти для объекта \(при необходимости резервируется новая память\). Если памяти хватает, выделяется память начиная с адреса на который указывает NextObjPth.

### Устройство кучи

Куча - это зарезервированная область памяти \(резервируется при инициализации процесса\) и указатель, который Рихтер называет NextObjPtr - указатель на место, где память будет выделяться для следующего объекта.

По мере заполнения кучи выделяются новые области памяти, вплоть до того как не будет исчерпан размер всего адресного пространства процесса.

### Алгоритм уборки мусора

Это упрощённое описание алгоритма.

1. При заполнении места выделенного для поколения 0 начинается уборка мусора.
2. Приостанавливаются все потоки приложения.
3. Начинается фаза маркировки
   1. Все объекты в куче помечаются для удаления
   2. Проверяются все достижимые для приложения объекты и помечаются как активные
4. Начинается фаза сжатия
   1. CLR перемещает в куче к началу все достижимые объекты \(это сокращает рабочий набор приложения\)
   2. Адреса ссылок на сдвинутые объекты обновляются, так чтобы объекты продолжали быть достижимыми
   3. NextObjPtr обновляется и указывает на следующий адрес за последним объектом в куче.
5. Если место в куче не удалось освободить, а память процесса исчерпана, то вылетает OutOfMemoryException.

Рихтер определяет корни так - это все переменные ссылочного типа \(а не точки, которые доступны для приложения\). На данный момент не понятно, как ищутся корни.

### Уборка мусора и отладка

Рассказывается о особенностях работы уборки мусора в режимах Debug и Release.

В Release уборка мусора очистит все корни, которые уже пройдены в методе и больше использоваться не будут.

В Debug никакие корни метода не будут удаляться, пока метод не будет завершён.

Приводится пример c timer и callback. callback вызывает явную уборку мусора и в релизе callback будет вызван всего один раз, так как при его вызове объект таймер будет удалён и больше не будет вызывать callback.

### Поколения

* На данный момент объекты могут относиться к одному из трёх поколений
* Для каждого поколения CLR выбирает пороговый размер в куче

**Общее описание алгоритма:**

**Когда первышен размер выделенный для поколений, в этих поколениях производится уборка мусора, но точный алгоритм не ясен \(с точным порядком действий\) и дальше в описании алгоритма могут быть ошибки.**

* При создании нового объекта сборщик мусора смотрит не был ли превышен размер выделенный для объектов в поколении 0. 

* Если размер для поколения 0 превышен, то смотрится не превышен ли размер в поколениях 1 и 2
* Если не превышен, то мусор собирается только в поколении 0
* Если превышен, то мусор собирается и в этих поколениях \(то есть если после уборки мусора в 0 или 1 поколении размер будет превышен в старшем поколении, то это будет известно только при следующей уборке мусора\)
* Уборщик мусора изменяет свой поведение в зависимости от ситуации - он может увеличивать или уменьшать размер поколений.

Оптимизации уборки мусора:

* Объекты лежащие в вышестоящих поколениях не проверяются \(это само собой понятно\)
* Если корень ссылается не объект в вышестоящем поколении эти ссылки игнорируются и граф по ним не строится
  * Для того чтобы отследить момент, когда объекту из старшего поколения присваивается ссылка на объект из младшего поколения - существует специальный механизм \(похоже этот механизм тупо отслеживает все изменения объектов в 1 и 2 поколении\)

**Специальный механизм отслеживания ссылок появившиеся из старшего поколения на младшее**

Отслеживается какие объекты изменялись с последней уборки мусора и такие объекты проверяются - нет ли у них ссылок на младшее поколение.

Джит-компилятор создаёт специальный код, когда модифицируется ссылочное поле внутри объекта. Туда входит проверка не принадлежит ли этот объект к 1 или 2 поколению. В случае если принадлежит, устанавливается бит в специальную таблицу - эта таблица карта с адресами кучи \(по одному биту для каждого 128-байтного диапазонаа данных в куче\). В начале следующей уборки мусора из таблицы видно, какие объекты менялись с прошлой уборки. После уборки мусора всем битам таблицы присваиваются нулевые значения. Из-за встраивания этого метода в приложении уменьшается производительность.

#### Запуск уборки мусора

#### Большие объекты

#### Режимы уборки мусора

#### Программное управление уборщиком мусора

#### Мониторинг использования памяти приложением

### Освобождение ресурсов при помощи механизма финализации

### Мониторинг и контроль времени жизни объектов



